C51 COMPILER V9.01   TOUCH                                                                 02/22/2014 15:45:07 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE TOUCH
OBJECT MODULE PLACED IN touch.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE touch\touch.c LARGE BROWSE DEBUG OBJECTEXTEND PRINT(.\touch.lst) OBJECT(tou
                    -ch.obj)

line level    source

   1          #include <reg51.h>
   2          #include <intrins.h>
   3          #include <sys\sys.h>
   4          #include <touch\touch.h>
   5          #include <lcd\lcd.h>
   6          
   7          //***Òò´¥ÃþÆÁÅú´Î²»Í¬µÈÔ­Òò£¬Ä¬ÈÏµÄÐ£×¼²ÎÊýÖµ¿ÉÄÜ»áÒýÆð´¥ÃþÊ¶±ð²»×¼£¬½¨ÒéÐ£×¼ºóÔÙÊ¹ÓÃ£¬²»½¨ÒéÊ¹ÓÃ¹Ì¶¨µÄÄ¬È
             -ÏÐ£×¼²ÎÊý
   8          //u16 vx=4809,vy=7382;  //±ÈÀýÒò×Ó£¬´ËÖµ³ýÒÔ1000Ö®ºó±íÊ¾¶àÉÙ¸öADÖµ´ú±íÒ»¸öÏñËØµã
   9          //u16 chx=102,chy=296;//Ä¬ÈÏÏñËØµã×ø±êÎª0Ê±µÄADÆðÊ¼Öµ
  10          u16 vx=4835,vy=7749;  //±ÈÀýÒò×Ó£¬´ËÖµ³ýÒÔ1000Ö®ºó±íÊ¾¶àÉÙ¸öADÖµ´ú±íÒ»¸öÏñËØµã
  11          u16 chx=3957,chy=225;//Ä¬ÈÏÏñËØµã×ø±êÎª0Ê±µÄADÆðÊ¼Öµ
  12          //***Òò´¥ÃþÆÁÅú´Î²»Í¬µÈÔ­Òò£¬Ä¬ÈÏµÄÐ£×¼²ÎÊýÖµ¿ÉÄÜ»áÒýÆð´¥ÃþÊ¶±ð²»×¼£¬½¨ÒéÐ£×¼ºóÔÙÊ¹ÓÃ£¬²»½¨ÒéÊ¹ÓÃ¹Ì¶¨µÄÄ¬È
             -ÏÐ£×¼²ÎÊý
  13          
  14          struct tp_pix_  tp_pixad,tp_pixlcd;      //µ±Ç°´¥¿Ø×ø±êµÄADÖµ,Ç°´¥¿Ø×ø±êµÄÏñËØÖµ   
  15          
  16          
  17          u8 tpstate(void)
  18          {
  19   1              return  Penirq;
  20   1      }
  21          //**********************************************************
  22          void spistar(void)                                     //SPI¿ªÊ¼
  23          {
  24   1      CS=1;
  25   1      DCLK=1;
  26   1      DIN=1;
  27   1      DCLK=1;
  28   1      }
  29          //**********************************************************
  30          void WriteCharTo7843(unsigned char num)          //SPIÐ´Êý¾Ý
  31          {
  32   1              u8 count=0;   
  33   1              for(count=0;count<8;count++)  
  34   1              {         
  35   2                      if(num&0x80)DIN=1;  
  36   2                      else DIN=0;   
  37   2                      num<<=1;    
  38   2                      DCLK=0;          
  39   2                      DCLK=1;         //ÉÏÉýÑØÓÐÐ§            
  40   2              }
  41   1      }
  42          //**********************************************************
  43          u16 ReadFromCharFrom7843()             //SPI ¶ÁÊý¾Ý
  44          {
  45   1              u8 count=0; 
  46   1              u16 Num=0; 
  47   1               for(count=0;count<16;count++)//¶Á³ö16Î»Êý¾Ý,Ö»ÓÐ¸ß12Î»ÓÐÐ§ 
  48   1              {                                 
  49   2                      Num<<=1;         
  50   2                      DCLK=0; //ÏÂ½µÑØÓÐÐ§               
  51   2                      DCLK=1;
  52   2                      if(DOUT)Num++;           
C51 COMPILER V9.01   TOUCH                                                                 02/22/2014 15:45:07 PAGE 2   

  53   2              }       
  54   1              Num>>=4;        //Ö»ÓÐ¸ß12Î»ÓÐÐ§.               
  55   1              return Num;
  56   1      
  57   1      }       
  58          //´Ó7846/7843/XPT2046/UH7843/UH7846¶ÁÈ¡adcÖµ      0x90=y   0xd0-x
  59          u16 ADS_Read_AD(unsigned char CMD)          
  60          {
  61   1              u16 l;
  62   1              CS=0;
  63   1              WriteCharTo7843(CMD);        //ËÍ¿ØÖÆ×Ö¼´ÓÃ²î·Ö·½Ê½¶ÁX×ø±ê ÏêÏ¸Çë¼ûÓÐ¹Ø×ÊÁÏ
  64   1              _nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_
             -nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();
  65   1              _nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_
             -nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();
  66   1              _nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_
             -nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();
  67   1              _nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_
             -nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();
  68   1              _nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_
             -nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();
  69   1              DCLK=0;                     
  70   1              _nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_
             -nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();          
  71   1              DCLK=1;         //¸ø1¸öÊ±ÖÓ£¬Çå³ýBUSY               
  72   1              DCLK=0; 
  73   1              l=ReadFromCharFrom7843();
  74   1              CS=1;
  75   1      return l;
  76   1      }                  
  77          //¶ÁÈ¡Ò»¸ö×ø±êÖµ
  78          //Á¬Ðø¶ÁÈ¡READ_TIMES´ÎÊý¾Ý,¶ÔÕâÐ©Êý¾ÝÉýÐòÅÅÁÐ,
  79          //È»ºóÈ¥µô×îµÍºÍ×î¸ßLOST_VAL¸öÊý,È¡Æ½¾ùÖµ 
  80          #define READ_TIMES 5 //¶ÁÈ¡´ÎÊý
  81          #define LOST_VAL 1        //¶ªÆúÖµ
  82          u16 ADS_Read_XY(u8 xy)
  83          {
  84   1              u16 i, j;
  85   1              u16 buf[READ_TIMES];
  86   1              u16 sum=0;
  87   1              u16 temp;
  88   1              for(i=0;i<READ_TIMES;i++)
  89   1              {                                
  90   2                      buf[i]=ADS_Read_AD(xy);     
  91   2              }                                   
  92   1              for(i=0;i<READ_TIMES-1; i++)//ÅÅÐò
  93   1              {
  94   2                      for(j=i+1;j<READ_TIMES;j++)
  95   2                      {
  96   3                              if(buf[i]>buf[j])//ÉýÐòÅÅÁÐ
  97   3                              {
  98   4                                      temp=buf[i];
  99   4                                      buf[i]=buf[j];
 100   4                                      buf[j]=temp;
 101   4                              }
 102   3                      }
 103   2              }         
 104   1              sum=0;
 105   1              for(i=LOST_VAL;i<READ_TIMES-LOST_VAL;i++)sum+=buf[i];
 106   1              temp=sum/(READ_TIMES-2*LOST_VAL);
 107   1              return temp;   
 108   1      } 
C51 COMPILER V9.01   TOUCH                                                                 02/22/2014 15:45:07 PAGE 3   

 109          //´øÂË²¨µÄ×ø±ê¶ÁÈ¡
 110          //×îÐ¡Öµ²»ÄÜÉÙÓÚ100.
 111          u8 Read_ADS(u16 *x,u16 *y)
 112          {
 113   1              u16 xtemp,ytemp;                                                  
 114   1              xtemp=ADS_Read_XY(CMD_RDX);
 115   1              ytemp=ADS_Read_XY(CMD_RDY);                                                                                
 116   1              if(xtemp<100||ytemp<100)return 0;//¶ÁÊýÊ§°Ü
 117   1              *x=xtemp;
 118   1              *y=ytemp;
 119   1              return 1;//¶ÁÊý³É¹¦
 120   1      }
 121          //2´Î¶ÁÈ¡ADS7846,Á¬Ðø¶ÁÈ¡2´ÎÓÐÐ§µÄADÖµ,ÇÒÕâÁ½´ÎµÄÆ«²î²»ÄÜ³¬¹ý
 122          //50,Âú×ãÌõ¼þ,ÔòÈÏÎª¶ÁÊýÕýÈ·,·ñÔò¶ÁÊý´íÎó.         
 123          //¸Ãº¯ÊýÄÜ´ó´óÌá¸ß×¼È·¶È
 124          #define ERR_RANGE 50 //Îó²î·¶Î§ 
 125          u8 Read_ADS2(u16 *x,u16 *y) 
 126          {
 127   1              u16 x1,y1;
 128   1              u16 x2,y2;
 129   1              u8 flag;    
 130   1          flag=Read_ADS(&x1,&y1);   
 131   1          if(flag==0)return(0);
 132   1          flag=Read_ADS(&x2,&y2);     
 133   1          if(flag==0)return(0);   
 134   1          if(((x2<=x1&&x1<x2+ERR_RANGE)||(x1<=x2&&x2<x1+ERR_RANGE))//Ç°ºóÁ½´Î²ÉÑùÔÚ+-ERR_RANGEÄÚ
 135   1          &&((y2<=y1&&y1<y2+ERR_RANGE)||(y1<=y2&&y2<y1+ERR_RANGE)))
 136   1          {
 137   2              *x=(x1+x2)>>1;
 138   2              *y=(y1+y2)>>1;          
 139   2              return 1;
 140   2          }else return 0;       
 141   1      } 
 142          //¾«È·¶ÁÈ¡Ò»´Î×ø±ê,Ð£×¼µÄÊ±ºòÓÃµÄ          
 143          u8 Read_TP_Once(void)
 144          {
 145   1              u8 re=0;
 146   1              u16 x1,y1;
 147   1              u16 x2,y2;
 148   1              while(re==0)
 149   1              {
 150   2                      while(!Read_ADS2(&x1,&y1));
 151   2                      delayms(10);
 152   2                      while(!Read_ADS2(&x2,&y2));
 153   2                      if((x2<=x1&&x1<x2+3)||(x1<=x2&&x2<x1+3))
 154   2                      {
 155   3                              tp_pixad.x=(x1+x2)/2;
 156   3                              tp_pixad.y=(y1+y2)/2;
 157   3                              re=1; 
 158   3                      }       
 159   2              } 
 160   1              return re;
 161   1      }
 162          //////////////////////////////////////////////////
 163          //ÓëLCD²¿·ÖÓÐ¹ØµÄº¯Êý  
 164          //»­Ò»¸ö´¥Ãþµã
 165          //ÓÃÀ´Ð£×¼ÓÃµÄ
 166          void Drow_Touch_Point(u16 x,u16 y)
 167          {
 168   1              LCD_DrawLine(x-12,y,x+13,y);//ºáÏß
 169   1              LCD_DrawLine(x,y-12,x,y+13);//ÊúÏß
 170   1              LCD_DrawPoint(x+1,y+1);
C51 COMPILER V9.01   TOUCH                                                                 02/22/2014 15:45:07 PAGE 4   

 171   1              LCD_DrawPoint(x-1,y+1);
 172   1              LCD_DrawPoint(x+1,y-1);
 173   1              LCD_DrawPoint(x-1,y-1);
 174   1      //      Draw_Circle(x,y,6);//»­ÖÐÐÄÈ¦
 175   1      }         
 176          //×ª»»½á¹û
 177          //¸ù¾Ý´¥ÃþÆÁµÄÐ£×¼²ÎÊýÀ´¾ö¶¨×ª»»ºóµÄ½á¹û,±£´æÔÚX0,Y0ÖÐ
 178          u8 Convert_Pos(void)
 179          {                        
 180   1              u8 l=0; 
 181   1              if(Read_ADS2(&tp_pixad.x,&tp_pixad.y))
 182   1              {
 183   2                      l=1;
 184   2                      tp_pixlcd.x=tp_pixad.x>chx?((u32)tp_pixad.x-(u32)chx)*1000/vx:((u32)chx-(u32)tp_pixad.x)*1000/vx;
 185   2                      tp_pixlcd.y=tp_pixad.y>chy?((u32)tp_pixad.y-(u32)chy)*1000/vy:((u32)chy-(u32)tp_pixad.y)*1000/vy;
 186   2              }
 187   1              return l;
 188   1      }          
 189          //´¥ÃþÆÁÐ£×¼´úÂë
 190          //µÃµ½ËÄ¸öÐ£×¼²ÎÊý
 191          #define tp_pianyi 80   //Ð£×¼×ø±êÆ«ÒÆÁ¿ 
 192          #define tp_xiaozhun 2000   //Ð£×¼¾«¶È
 193          void Touch_Adjust(void)
 194          {       
 195   1              float vx1,vx2,vy1,vy2;  //±ÈÀýÒò×Ó£¬´ËÖµ³ýÒÔ1000Ö®ºó±íÊ¾¶àÉÙ¸öADÖµ´ú±íÒ»¸öÏñËØµã
 196   1              u16 chx1,chx2,chy1,chy2;//Ä¬ÈÏÏñËØµã×ø±êÎª0Ê±µÄADÆðÊ¼Öµ
 197   1              u16 lx,ly;                               
 198   1              struct tp_pixu32_ p[4];
 199   1              u8  cnt=0;       
 200   1              cnt=0;                          
 201   1              POINT_COLOR=BLUE;
 202   1              BACK_COLOR =WHITE;
 203   1              LCD_Clear(WHITE);//ÇåÆÁ   
 204   1              POINT_COLOR=RED;//ºìÉ« 
 205   1              LCD_Clear(WHITE);//ÇåÆÁ 
 206   1              Drow_Touch_Point(tp_pianyi,tp_pianyi);//»­µã1 
 207   1              while(1)
 208   1              {
 209   2                      if(Penirq==0)//°´¼ü°´ÏÂÁË
 210   2                      {
 211   3                              if(Read_TP_Once())//µÃµ½µ¥´Î°´¼üÖµ
 212   3                              {                                                                  
 213   4                                      p[cnt].x=tp_pixad.x;
 214   4                                      p[cnt].y=tp_pixad.y;
 215   4                                      cnt++; 
 216   4                              }                        
 217   3                              switch(cnt)
 218   3                              {                          
 219   4                                      case 1:
 220   4                                              LCD_Clear(WHITE);//ÇåÆÁ 
 221   4                                              while(!Penirq)  //µÈ´ýËÉÊÖ
 222   4                                              {
 223   5                                              }
 224   4                                              Drow_Touch_Point(LCD_W-tp_pianyi-1,tp_pianyi);//»­µã2
 225   4                                              break;
 226   4                                      case 2:
 227   4                                              LCD_Clear(WHITE);//ÇåÆÁ 
 228   4                                              while(!Penirq)  //µÈ´ýËÉÊÖ
 229   4                                              {
 230   5                                              }
 231   4                                              Drow_Touch_Point(tp_pianyi,LCD_H-tp_pianyi-1);//»­µã3
 232   4                                              break;
C51 COMPILER V9.01   TOUCH                                                                 02/22/2014 15:45:07 PAGE 5   

 233   4                                      case 3:
 234   4                                              LCD_Clear(WHITE);//ÇåÆÁ 
 235   4                                              while(!Penirq)  //µÈ´ýËÉÊÖ
 236   4                                              {
 237   5                                              }
 238   4                                              Drow_Touch_Point(LCD_W-tp_pianyi-1,LCD_H-tp_pianyi-1);//»­µã4
 239   4                                              break;
 240   4                                      case 4:  //È«²¿ËÄ¸öµãÒÑ¾­µÃµ½
 241   4                                      LCD_Clear(WHITE);//ÇåÆÁ 
 242   4                                              while(!Penirq)  //µÈ´ýËÉÊÖ
 243   4                                              {
 244   5                                              }
 245   4                                              vx1=p[1].x>p[0].x?(p[1].x-p[0].x+1)*1000/(LCD_W-tp_pianyi-tp_pianyi):(p[0].x-p[1].x-1)*1000/(LCD_W
             --tp_pianyi-tp_pianyi);
 246   4                                              chx1=p[1].x>p[0].x?p[0].x-(vx1*tp_pianyi)/1000:p[0].x+(vx1*tp_pianyi)/1000;
 247   4                                              vy1=p[2].y>p[0].y?(p[2].y-p[0].y-1)*1000/(LCD_H-tp_pianyi-tp_pianyi):(p[0].y-p[2].y-1)*1000/(LCD_H
             --tp_pianyi-tp_pianyi);
 248   4                                              chy1=p[2].y>p[0].y?p[0].y-(vy1*tp_pianyi)/1000:p[0].y+(vy1*tp_pianyi)/1000; 
 249   4                                              
 250   4                                              vx2=p[3].x>p[2].x?(p[3].x-p[2].x+1)*1000/(LCD_W-tp_pianyi-tp_pianyi):(p[2].x-p[3].x-1)*1000/(LCD_W-tp
             -_pianyi-tp_pianyi);
 251   4                                              chx2=p[3].x>p[2].x?p[2].x-(vx2*tp_pianyi)/1000:p[2].x+(vx2*tp_pianyi)/1000;
 252   4                                              vy2=p[3].y>p[1].y?(p[3].y-p[1].y-1)*1000/(LCD_H-tp_pianyi-tp_pianyi):(p[1].y-p[3].y-1)*1000/(LCD_H
             --tp_pianyi-tp_pianyi);
 253   4                                              chy2=p[3].y>p[1].y?p[1].y-(vy2*tp_pianyi)/1000:p[1].y+(vy2*tp_pianyi)/1000; 
 254   4      
 255   4      
 256   4                                              if((vx1>vx2&&vx1>vx2+tp_xiaozhun)||(vx1<vx2&&vx1<vx2-tp_xiaozhun)||(vy1>vy2&&vy1>vy2+tp_xiaozhun)||(v
             -y1<vy2&&vy1<vy2-tp_xiaozhun))
 257   4                                              {
 258   5                                                      cnt=0;
 259   5                                                      LCD_Clear(WHITE);//ÇåÆÁ 
 260   5                                                      Drow_Touch_Point(tp_pianyi,tp_pianyi);//»­µã1 
 261   5                                                      continue;
 262   5                                              }
 263   4                                              vx=(vx1+vx2)/2;vy=(vy1+vy2)/2;
 264   4                                              chx=(chx1+chx2)/2;chy=(chy1+chy2)/2;    
 265   4                                                                                                                                      
 266   4                                              //ÏÔÊ¾Ð£×¼ÐÅÏ¢
 267   4                                              LCD_Clear(WHITE);//ÇåÆÁ 
 268   4                                              POINT_COLOR=BLACK;
 269   4                                              BACK_COLOR=BLUE;        
 270   4                              
 271   4                                              lx=0;ly=50;                     
 272   4                                              LCD_ShowString(lx,ly,"VX1:");lx+=40;LCD_ShowNum(lx,ly,vx1,4);                                   
 273   4                                              lx=0;ly+=20;
 274   4                                              LCD_ShowString(lx,ly,"Vy1:");lx+=40;LCD_ShowNum(lx,ly,vy1,4);                                   
 275   4                                              lx=0;ly+=20; 
 276   4                                              LCD_ShowString(lx,ly,"CHX1:");lx+=40;LCD_ShowNum(lx,ly,chx1,4);                                 
 277   4                                          lx=0;ly+=20; 
 278   4                                              LCD_ShowString(lx,ly,"CHY1:");lx+=40;LCD_ShowNum(lx,ly,chy1,4);
 279   4      
 280   4                                              lx=100;ly=50;                   
 281   4                                              LCD_ShowString(lx,ly,"VX2:");lx+=40;LCD_ShowNum(lx,ly,vx2,4);                                   
 282   4                                              lx=100;ly+=20;
 283   4                                              LCD_ShowString(lx,ly,"Vy2:");lx+=40;LCD_ShowNum(lx,ly,vy2,4);                                   
 284   4                                              lx=100;ly+=20; 
 285   4                                              LCD_ShowString(lx,ly,"CHX2:");lx+=40;LCD_ShowNum(lx,ly,chx2,4);                                 
 286   4                                          lx=100;ly+=20; 
 287   4                                              LCD_ShowString(lx,ly,"CHY2:");lx+=40;LCD_ShowNum(lx,ly,chy2,4);
 288   4                                      
 289   4                                              lx=50;ly=150;                   
C51 COMPILER V9.01   TOUCH                                                                 02/22/2014 15:45:07 PAGE 6   

 290   4                                              LCD_ShowString(lx,ly,"VX:");lx+=40;LCD_ShowNum(lx,ly,vx,4);                                     
 291   4                                              lx=50;ly+=20;
 292   4                                              LCD_ShowString(lx,ly,"Vy:");lx+=40;LCD_ShowNum(lx,ly,vy,4);                                     
 293   4                                              lx=50;ly+=20; 
 294   4                                              LCD_ShowString(lx,ly,"CHX:");lx+=40;LCD_ShowNum(lx,ly,chx,4);                                   
 295   4                                          lx=50;ly+=20; 
 296   4                                              LCD_ShowString(lx,ly,"CHY:");lx+=40;LCD_ShowNum(lx,ly,chy,4);
 297   4      
 298   4                                              lx=30;ly+=30;
 299   4                                              LCD_ShowString(lx,ly,"Adjust OK!  Touch Anywhere To Continue");                                                                           
 300   4                                              Read_TP_Once(); //µÈ´ýÈÎÒâ¼üºó¼ÌÐø
 301   4      
 302   4                                              LCD_Clear(WHITE);//ÇåÆÁ
 303   4                                              return;//Ð£ÕýÍê³É                                
 304   4                              }
 305   3                      }
 306   2              } 
 307   1      }
 308          void point(void) //»æÍ¼º¯Êý
 309          {
 310   1              double t=0;
 311   1              
 312   1          while(1)
 313   1              {       
 314   2                      if(Penirq==0)
 315   2                      {
 316   3                              t=0;
 317   3                              if(Convert_Pos())       //µÃµ½×ø±êÖµ
 318   3                              {
 319   4                              //      LCD_ShowString(10,250,"X:");LCD_ShowNum(30,250,(u32)tp_pixad.x,6);      
 320   4                                      //LCD_ShowString(180,250,"Y:");LCD_ShowNum(200,250,(u32)tp_pixad.y,6);  
 321   4                                      LCD_ShowString(10,250,"X:");LCD_ShowNum(30,250,tp_pixad.x,4);
 322   4                                      LCD_ShowString(180,250,"Y:");LCD_ShowNum(200,250,tp_pixad.y,4);                                 
 323   4                                      LCD_DrawPoint_big(tp_pixlcd.x,tp_pixlcd.y);   
 324   4                               }
 325   3                              
 326   3                      }
 327   2                      else
 328   2                      {       
 329   3                              t++;            
 330   3                              if(t>65000)
 331   3                              {
 332   4                                      return;
 333   4                              }
 334   3                      }               
 335   2      
 336   2                      }
 337   1      }               


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   5168    ----
   CONSTANT SIZE    =    107    ----
   XDATA SIZE       =     16     117
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
